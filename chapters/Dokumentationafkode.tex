\chapter{Dokumentation af kode}

\noindent For at kunne skabe et passende overblik over hvordan og hvorledes koden er konstrureret, har vi valgt at dele dokumentationen op i nogle overordnede kategorier, som reflekterer spillets forskellige aspekter. Der er tale om klasserne Main, Board, Dice, Game samt en tekstfil, der indeholder oversættelsen.
Til indikation af tekstombryd i koden vil følgende symbol bruges '...'.\\

\section{Main}
\noindent Main klassen anses for at være et typisk startspunkt ved opstartskonfigurationer i Java applikationer. 
Et godt råd når det kommer til kodning i Java, er at holde main metoden så vidt som muligt kodefri, forstået således at kun den nødvendig kode som tillader programmet at starte skal finde sted i main. 
Følgende er et udrag af vores \textit{Main.java} klasse.\\

\begin{lstlisting}
    public class Main {
        public static void main(String[] args) {
            Translate.setLang("da_DK");
    
            Board.boardgame();
    
            Game game = new Game();
            game.askForPlayers(2);
            game.play();
        }
    }
\end{lstlisting}
\vspace{2ex}

\noindent Ved programmets opstart bliver sproget som standard sat til dansk, nemlig via oversættelsesfilen da\char`_DK.txt. 
Eftersom programmet indstiller det valgte sprog, bliver \textit{Board.boardgame} indlæst. 
Derefter oprettes der et game instans, hvor to spillerer indtaster navn og spillet går i gang.\\

\section{Board og feltlister}
\noindent Spillet gør brug af en tidligere udført GUI til visuel fremvisning af spillerer, brikker samt andre vigtige meddelelser. 
Den udleverede GUI skulle gennemgå nogle ændringer før, at den kunne vise sig at være brugbar i vores projekt. 
Følgende er et udrag af vores \textit{Board.java} klasse.\\
\begin{lstlisting}
public class Board {
    public static void boardgame()
    {
    import desktop_fields.Street;
    import desktop_fields.Field;
    import desktop_resources.*;
    import java.awt.*;
        
    //Eksempel paa et felt
    Field[] fields = new Field[12];
        fields[3] = new Street.Builder()
        .setTitle("Palace gates")
        .setBgColor(Color.GREEN)
        .setSubText("+100")
        .setDescription(Translate.t("field.palace_gates.description"))
        .build();
        ...
        GUI.create(fields);
    }
}        
\end{lstlisting}
\vspace{2ex}

\noindent For at kunne bruge GUI'en i vores projekt skulle vi udfører et par modifikationer, for at få front- og bakend til spille sammen. 
Først og fremmest importerede vi \textit{desktop\char`_resources} samt \textit{desktop\char`_fields- .Street og .Field}, hvilket tillod os at hente informationer vedrørende struktur, layout(udseende) m.m. fra den vedlagte GUI. 
Eftersom at henvisningerne til de nødvendige ressourcer er etableret, kan vi begynde med at indføre de opkrævede felter. 
Dette opnås ved at lave et array ved navn fields bestående af 12 felter. 
Et felt består sådan set af en titel, baggrundsfarve, subtekst som bruges til indikering af værdi, beskrivelse af felt hvor i der henvises til oversættelsesfilen samt kommandoen build. 
\textit{GUI.create(fields);} metoden tager udgangspunkt i de 11 fields (felt 0 også regnet med, dvs 12) og derefter skaber visuelt de omtalte felter ved brug af \textit{GUI.create} metoden på brættet.\\

\section{Dice, terning}
\noindent Terningesæt i dette projekt består af to terninger. 
Følgende er et udrag af vores \textit{Dice.java} klasse.\\
\begin{lstlisting}
    //Klassen 'Dice'    
    public class Dice {
        private int faceValue;
        private int numberOfEyes;
    
        public Dice()
        {
            this.numberOfEyes = 6;
        }
    
        public Dice(int numberOfEyes)
        {
            this.numberOfEyes = numberOfEyes;
        }
    
        public int getNumberOfEyes()
        {
            return this.numberOfEyes;
        }
    
        public int getFaceValue()
        {
            return this.faceValue;
        }
    
        public void roll()
        {
            this.faceValue = (int) (Math.random() * this.numberOfEyes) + 1;
        }
    }
\end{lstlisting}
\vspace{2ex}

\noindent Måden som vi har valgt at implementerer terning på således at der startes med definering af en privat integer ved navn \textit{faceValue}.
Herefter definerer vi også endu en privat integer ved navn \textit{numberOfEyes}.
Idéen med \textit{numberOfEyes} er at tillade brugen af terninger med specifik øjeantal der er til forskel fra den velkendte 6-sidet terning.
Vi indfører derefter en metode ved navn \textit{roll}, bestående af \textit{faceValue}.
Dette svarer så til en \textit{Math.random} funktion der multipliceres med \textit{numberOfEyes} og efterfølgende adderes med 1.
Når der skal rulles med terningerne tages der udgangspunkt i metoden \textit{roll}.
En public integer ved navn \textit{getNumberOfEyes} returner \textit{this.numberOfEyes}.
En tilsvarende funktion, \textit{getFaceValue}, returner \textit{this.faceValue}.
\textit{getNumberOfEyes} og \textit{getFaceValue} giver information om øjeantal samt den slået værdi.\\

\section{Stash, pengebeholdning}
\noindent Stash eller pengebeholdning udgør det lager hvor spillerenes pengebeholdningen opbevares. 
Følgende er et udrag af vores \textit{Stash.java} klasse.\\
\begin{lstlisting}
    public class Stash {
        private int amount;
    
        public Stash()
        {
        }
    
        public Stash(int startAmount)
        {
            this.amount = startAmount;
        }
    
        public int getAmount()
        {
            return this.amount;
        }
    
        public void addAmount(int numberToAdd)
        {
            this.amount += numberToAdd;
    
            if (this.amount < 0) {
                this.amount = 0;
            }
        }
    }
\end{lstlisting}
\vspace{2ex}

\noindent Et af kravne var at spillerne startede med en pengebeholdning på 1000.
Dette opnås således ved at definerer en privat integer ved navn \textit{amount}, med en startsværdi på 1000.
Efterfølgende kan der ved brug af \textit{getAmount} returneres den nuværende pengebeholdning.
For at kunne tilføje til pengebeholdningen indfører vi metoden \textit{addAmount}, med et parameter ved navn \textit{numberToAdd}.
Et if-else statement kører netop som det første i \textit{addAmount} metoden, hvorpå sålænge \textit{this.amount} adderet med \textit{numberToAdd} er mindre end 0, så sættes \textit{this.amount} til at være ligemed 0.
Derimod hvis \textit{this.amount} adderet med \textit{numberToAdd} er større end 0, tilføjes beløbet til pengebeholdning.\\

\section{Player, spiller}
\noindent Klassen \textit{Player} udgør struktureren til hvordan og hvorledes spilleren interagerer med omverden samt deres attributter.
Følgende er et udrag af vores \textit{Player.java} klasse.\\
\begin{lstlisting}
    public class Player {
        private String name;
        private Stash stash;
    
        public Player(String name)
        {
            this.name = name;
            this.stash = new Stash(1000);
        }
    
        public String getName()
        {
            return this.name;
        }
    
        public int getAmount()
        {
            return this.stash.getAmount();
        }
    
        public void addAmount(int numberToAdd)
        {
            this.stash.addAmount(numberToAdd);
        }
    }     
\end{lstlisting}
\vspace{2ex}

\noindent Ved spillets opstart bliver spillerene 1 og 2 spurgt om et navn.
Dette opnås ved at gør brug af den indførte metode \textit{name}, hvor så den tilhørende pengebeholdning bindes spilleren via metoden \textit{stash}.
Derefter defineres via metoden \textit{Player}, at en spiller består af name, med en ny pengebeholdning på 1000.
Efterfølgende defineres metoder navngivet henholdsvis \textit{getName} og \textit{getAmount} som tager udgangspunkt i \textit{name} og \textit{stash} fra tidligere.
Sidst men ikke mindst specificerer vi, at metoden \textit{addAmount} med et parameter {numberToAdd}, skal tilføje de givne beløb under \textit{stash} eller pengebeholdning vha. af \textit{addAmount} fra \textit{Stash.java} gennemgået tidligere.\\

\section{Game, spil}
\noindent Følgende klasse indeholder større metoder sammenlignet med de andre klasser, hvor så det ikke er helt så praktisk, at give en fyldig beskrive af klassen.
I stedet nøjes med kommentarer i selve koden der forklarer metodernes formål.
Følgende er et udrag af vores \textit{Game.java} klasse.\\
\begin{lstlisting}
    //Start paa spil, Game
    public void play() {
    this.printWelcomeMessage();

    Player currentPlayer;
    boolean winnerFound;

    do {
        currentPlayer = getNextPlayer();

        this.print(Translate.t("turn.currentPlayer", ...
         new String[] {currentPlayer.getName()}));
        //Tilfoejer en knap som eksekverer foelgende while do saetning,...
        GUI.getUserButtonPressed("", "Kast");
        
        //Do while loop som ruller terningen, saetter terningen paa GUI, ...
        //saetter bil/spillerposition.
        do {
            GUI.removeAllCars(currentPlayer.getName());

            this.rollDies();

            GUI.setCar(fieldNumber, currentPlayer.getName());
            GUI.setDice(this.dies[0].getFaceValue(), 3, 8, ...
             this.dies[1].getFaceValue(), 4, 8);

             int fieldNumber = this.sum() - 2;
             
             this.print(new String[] {
                Translate.t("turn.rollResult", ...
                 new String[] {"" + sum()}),
                Translate.t("turn.position", new String[] ...
                 {this.fields[fieldNumber][1]}),
                Translate.t("field." + this.fields[fieldNumber][0] ...
                  + ".description"),
        });

        int score = this.fieldValues[fieldNumber];
        currentPlayer.addAmount(score);

        this.print(new String[] {
            Translate.t("turn.score", new String[] {"" + ...
             (score > 0 ? "+" : "") + score}),
            Translate.t("turn.scoreCurrent", new String[] {"" ...
             + currentPlayer.getAmount()}),
        });

            GUI.setBalance(currentPlayer.getName(),
            currentPlayer.getAmount());
        } while (this.sum() == 10);
        
        //Saa laenge at pengebeholdning er mindre eller lig med 3000,
        //saa kaares en vinder og spillet slutter
        winnerFound = currentPlayer.getAmount() >= 3000;
    } while (! winnerFound);

    this.printScoreBoard(currentPlayer);
    }
            
//Skift mellem spillerer
private Player getNextPlayer()
{
    if (this.playerIndex >= this.players.length) {
        this.playerIndex = 0;
    }
    return this.players[this.playerIndex++];
}

//Print af scoreboard
private void printScoreBoard(Player winningPlayer)
{
    String[] scoreboardText = new String[this.players.length + 2];

    scoreboardText[0] = Translate.t("scoreboard.title");

    for (int i = 1; i <= this.players.length; i++) {
        Player player = this.players[i - 1];

        scoreboardText[i] = " - " + player.getName() + ": ...
         " + player.getAmount();

        if (player == winningPlayer) {
            scoreboardText[i] = scoreboardText[i] + " " ...
            + Translate.t("scoreboard.winnerText");
        }
    }

    scoreboardText[this.players.length + 1] =
    Translate.t("scoreboard.winner", new String[] ...
    {winningPlayer.getName()});
    this.print(String.join("\n", scoreboardText));
}
\end{lstlisting}
\vspace{2ex}

\section{Translate, oversættelser}
\noindent Følgende klasse indeholder større metoder sammenlignet med de andre klasser, hvor så det ikke er helt så praktisk, at give en fyldig beskrive af klassen.
I stedet nøjes med kommentarer i selve koden der forklarer metodernes formål.
Følgende er et udrag af vores \textit{Game.java} samt \textit{Translate.java} klasse.
\begin{lstlisting}
    public class Translate {
        private static Translate instance;
        
        //Saetter standard sprog til at vaere dansk
        private static String lang = "da_DK";
        
        private HashMap<String, String> translations;

        //Metode som indlaeser oversaettelser fra tekst fil
        private Translate()
        {
            this.translations = new HashMap<String, String>(); ...
            this.parseFile("/languages/" + Translate.getLang() + ".txt");
        }

        public String get(String key)
        {
            if (! this.translations.containsKey(key)) {
                return key;
            }
    
            String translation = this.translations.get(key);
    
            if (translation.equals("")) {
                return key;
            }
            return translation;
        }
    
        public String get(String key, String[] variables)
        {
            String translation = this.get(key);
    
            if (! translation.equals(key)) {
                for (int i = 0; i < variables.length; i++) {
                    translation = translation.replaceAll ...
                     ("\\{\\{ ?#" + i + " ?\\}\\}", variables[i]);
                }
            }
            return translation;
        }
    
    //Skriver til oversaettelses tekstfil
    private void parseFile(String filePath)
    {
        try {
            InputStream in = this.getClass().getResourceAsStream(filePath);
            BufferedReader reader = new BufferedReader ...
             (new InputStreamReader(in));

            String currentLine;
            while ((currentLine = reader.readLine()) != null) {
                if (currentLine.equals("")) {
                    continue;
                }

                String[] keyValue = currentLine.split(":", 2);

                String key = keyValue[0];
                String val = keyValue.length == 1 ? "" : ...
                 this.parseValue(keyValue[1]);

                if (! this.translations.containsKey(key)) {
                    this.translations.put(key, val);
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
\end{lstlisting}
\vspace{2ex}
